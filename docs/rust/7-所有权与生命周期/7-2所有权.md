# 所有权

## Rust 的内存管理模型

所有权是 Rust 这门编程语言的核心概念, Rust 最引以为豪的内存安全就建立在所有权之上.

所有的编程语言都存在某种管理内存的机制, 拿 C 语言来说, 这种机制是 malloc 和 free. 这意味着开发者要手动管理内存. 对于编程高手而言, 这是一种拥有无限可能性的技术, 但对于大多数普通人而言, 它是一个 Bug 制造机器. 一些语言采用了垃圾回收技术来管理内存, 也就是说开发者可以只申请内存而不用手动去释放内存, 然后, 垃圾回收器, 也就是 GC, 会自动检测某块内存是否已经不再被使用, 如果是的话, 那么释放这块内存. 但是因为 GC 的存在导致程序性能天生的下降, 还有就是 GC 对程序运行带来的不确定性, 任何使用 GC 的语言几乎不可能用来编写底层程序. 我们这里说的底层是指贴近硬件的软件应用, 例如操作系统和硬件驱动.

在生活中, 如果有两种合理但不同的方法时, 你应该总是研究两者的结合, 看看能否找到两全其美的方法. 我们称这种组合为杂合(hybrid). 例如, 为什么只吃巧克力或简单的坚果, 而不是将两者结合起来, 成为一块可爱的坚果巧克力呢?

Rust 采用了一种中间方案 RAII(Resource Acquisition Is Initialization), 它兼具 GC 的易用性和安全性, 同时又有极高的性能.

## 栈和堆

在开始之前, 我们先来回顾一下堆和栈的区别. 栈是一种先进先出的数据结构, 栈内的每个元素都有固定的大小, 通常是你机器 CPU 的位宽. 例如, 如果你现在在使用 64 位机器, 那么你机器上运行的任何程序的栈的宽度就是 64 位, 正好是一个寄存器的大小. 另一方面, 如果我们要放置某个对象, 例如一个字符串, 由于字符串的长度是不固定的, 因此无法被放置在栈中. 此时我们必须使用堆, 而当我们想要在堆上分配一个对象, 我们向操作系统请求给定的内存数量, 操作系统会在可用堆中找到一个空闲位置, 然后讲标记设置为已占用, 并返回指向该存储位置的指针, 因此堆的组织性较差, 它比栈要慢, 但很多时候它是唯一的处理这些动态结构的方法. 下图展示了一个字符是如何存储在内存中的: 变量 s 保存在栈中, 其值是一个指向堆的地址, 堆中则保存了字符串的具体内容.

![image](../../images/rust%E5%A0%86%E5%92%8C%E6%A0%88.jpg)

## 所有权

所有权的实际规则.

- Rust 中每个值都绑定给一个变量, 称为该值的所有者.
- 每个值只有一个所有者, 而且每个值都有它的作用域.
- 一旦当这个值离开作用域, 这个值占用的内存将被回收.
