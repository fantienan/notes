# 静态生命周期

具有静态生命周期的引用在整个程序运行期间一直存在. 它使用 static 关键字. 具有静态生命周期的对象容易与常量搞混淆, 虽然两者都在整个程序运行之中存在, 但它们的区别是静态生命周期的对象有且只有一个内存地址, 而常量则不一定.

我们以下面这个例子来理解静态生命周期. 我们试图编写一个函数, 该函数返回一个字符串(&str). 但问题来了, 字符串的内容 “Hello World!” 的作用域是函数体, 而函数却试图返回它的引用. 为了解决这个问题, 需要将 &str 修改为 &'static str, 它表明其所引用的内容的生命周期是整个程序运行期间.

```rust
fn hello_world() -> &'static str {
    return "Hello World!";
}
```

## 何时应该使用静态生命周期

- 正在存储大量数据
- 静态对象的单地址属性是必需的
- 内部可变性是必需的(静态对象是允许可变的)

```rust
static mut LEVELS: u32 = 0;

fn main() {
    // 因为 static mut 允许多线程进行修改
    // 所以对 static mut 的修改必须放置在 unsafe 块中
    unsafe {
        println!("{}", LEVELS);
        LEVELS += 1;
        println!("{}", LEVELS);
    }
}
```
